<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Happy New Year Em y√™u</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÑ</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;600;700&family=Cinzel:wght@400;700&family=Pinyon+Script&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f0505;
            font-family: 'Cinzel', serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #bg-gradient {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: radial-gradient(circle at 50% 40%, #7b0d1e 0%, #4a0e16 50%, #1a0505 100%);
        }

        #black-void {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1.5s ease;
        }

        #frost-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.9);
            background: radial-gradient(circle, transparent 60%, rgba(20, 0, 5, 0.4) 100%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        #firework-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 6;
            pointer-events: none;
            display: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 10vh;
            transition: opacity 0.5s;
        }

        #main-title {
            font-family: 'Pinyon Script', cursive;
            font-size: 15vw;
            color: #eebb66;
            margin: 0;
            text-shadow: 0 2px 5px rgba(255, 215, 0, 0.3);
            animation: floatTitle 4s ease-in-out infinite;
            background: linear-gradient(to bottom, #fceabb 0%, #fccd4d 50%, #f8b500 51%, #fbdf93 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            line-height: 1.2;
        }

        #mode-indicator {
            font-family: 'Cinzel', serif;
            font-size: 3vw;
            font-weight: 700;
            color: #FFD700;
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-top: 10px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 5px;
        }

        #secret-message {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 8vw;
            width: 90%;
            white-space: normal;
            line-height: 1.3;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-align: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            background: linear-gradient(to bottom, #fff8db 0%, #FFD700 40%, #DAA520 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            transition: opacity 1.5s ease;
        }

        #ending-section {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 650px;
            max-height: 75vh;
            text-align: center;
            z-index: 100;
            opacity: 0;
            pointer-events: auto;
            transition: opacity 2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #ending-title {
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 7vw;
            margin: 0 0 15px 0;
            background: linear-gradient(to bottom, #fff8db 0%, #FFD700 40%, #ff6b6b 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            animation: glowPulse 2s ease-in-out infinite;
            flex-shrink: 0;
        }

        #ending-greeting {
            font-family: 'Be Vietnam Pro', sans-serif;
            font-weight: 500;
            font-size: 16px;
            color: #fff;
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.9);
            line-height: 1.8;
            margin: 0;
            padding: 20px 25px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(20, 10, 10, 0.8) 100%);
            border-radius: 15px;
            border: 1px solid rgba(255, 215, 0, 0.4);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 215, 0, 0.1);
            max-height: 50vh;
            overflow-y: auto;
            text-align: left;
            animation: fadeInUp 1s ease-out 0.5s both;
        }

        #ending-greeting::-webkit-scrollbar {
            width: 6px;
        }

        #ending-greeting::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        #ending-greeting::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #FFD700, #DAA520);
            border-radius: 3px;
        }

        @keyframes glowPulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (min-width: 768px) {
            #ending-title {
                font-size: 42px;
            }
            #ending-greeting {
                font-size: 18px;
                padding: 25px 30px;
            }
        }

        @media (max-width: 480px) {
            #ending-title {
                font-size: 28px;
            }
            #ending-greeting {
                font-size: 14px;
                padding: 15px 18px;
                max-height: 55vh;
            }
        }

        #lyrics-container {
            position: absolute;
            bottom: 20%;
            width: 100%;
            text-align: center;
            z-index: 20;
            pointer-events: none
        }

        #lyrics-text {
            font-family: 'Pinyon Script', cursive;
            font-size: 6vw;
            color: #fff0f5;
            text-shadow: 0 0 5px rgba(255, 200, 200, 0.5);
            padding: 0 20px;
            transition: all 0.3s ease;
        }

        #webcam-wrapper {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 75px;
            z-index: 50;
            background: #000;
            border: 1px solid #FFD700;
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            overflow: hidden;
            opacity: 0.6;
        }

        #webcam-canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            border-radius: 2px;
        }

        #cam-stats {
            display: none;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 5, 5, 0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: opacity .8s
        }

        .start-btn {
            border: 1px solid #eebb66;
            padding: 15px 30px;
            color: #eebb66;
            font-size: 14px;
            font-family: 'Cinzel', serif;
            letter-spacing: 4px;
            text-transform: uppercase;
            background: rgba(0, 0, 0, 0.6);
            margin-bottom: 15px;
            box-shadow: 0 0 20px rgba(238, 187, 102, 0.2);
            transition: all 0.3s;
        }

        .start-note {
            color: #886666;
            font-size: 12px;
            font-style: italic;
        }

        #touch-hint {
            position: absolute;
            bottom: 100px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: rgba(255, 215, 0, 0.5);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        @keyframes floatTitle {

            0%,
            100% {
                transform: translateY(0)
            }

            50% {
                transform: translateY(-8px)
            }
        }

        @media (min-width: 768px) {
            #main-title {
                font-size: 80px;
            }

            #mode-indicator {
                font-size: 9px;
            }

            #secret-message {
                font-size: 5vw;
                width: 80%;
            }

            #lyrics-text {
                font-size: 32px;
            }

            #webcam-wrapper {
                width: 150px;
                height: 112px;
                opacity: 1;
            }

            #cam-stats {
                display: block;
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                text-align: center;
                font-family: 'Cinzel', serif;
                font-size: 6px;
                font-weight: 700;
                color: #FFD700;
                letter-spacing: 2px;
                text-transform: uppercase;
                z-index: 26;
                background: rgba(0, 0, 0, 0.8);
                padding: 4px 0;
                border-top: 1px solid #FFD700;
            }
        }
    </style>
    <!-- Importmap removed, using local node_modules with Vite -->
    <!-- <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js","three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/"}}</script> -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>

<body>
    <div id="black-void"></div>
    <div id="bg-gradient"></div>
    <div id="frost-overlay"></div>

    <div id="canvas-container"></div>
    <canvas id="firework-canvas"></canvas>

    <div id="secret-message">HAPPY NEW YEAR</div>
    <div id="ending-section">
        <h1 id="ending-title">‚ú® HAPPY NEW YEAR 2026 ‚ú®</h1>
        <p id="ending-greeting"> Ch√∫c m·ª´ng nƒÉm m·ªõi ch√∫ng m√¨nh n·∫°. hihi, m·ªôt nƒÉm th·∫≠t tuy·ªát v·ªùi ch√∫ng m√¨nh. Ch√∫ng m√¨nh ƒë√£ c√πng nhau tr·∫£i qua m·ªôt nƒÉm th·∫≠t ƒë√°ng nh·ªõ v√† nhi·ªÅu kho·∫£nh kh·∫Øc tuy·ªát v·ªùi. V√† ƒë·∫∑c bi·ªát nh·∫•t l√† ch√∫ng m√¨nh ƒë√£ th·ª±c hi·ªán l·ªùi h·ª©a t·ª´ 1 nƒÉm tr∆∞·ªõc. C√πng ƒë√≥n ph√°o hoa ƒë√™m m1 n·ªØa n√†. M·ªôt l·ªùi n√≥i vu v∆° nh∆∞ng l·∫°i th√†nh hi·ªán th·ª±c r√πi. B√© c√≥ t·ª´ng h·ªèi anh ƒëi·ªÅu m√† anh c·∫£m th·∫•y tuy·ªát v·ªùi nh·∫•t trong nƒÉm 2025 ph·∫£i kh√¥ng ·∫°. ƒê·ªëi v·ªõi anh, th√†nh c√¥ng l·ªõn nh·∫•t trong nƒÉm l√† c√≥ em b√©, b√© t·ª´ m·ªôt ng∆∞·ªùi b·∫°n ƒë·ªìng h√†nh, ng∆∞·ªùi chia s·∫ª v√† th√†nh ng∆∞·ªùi y√™u anh. B√© l√† ƒëi·ªÉm t·ª±a c≈©ng nh∆∞ ngu·ªìn ƒë·ªông l·ª±c ƒë·ªÉ anh ti·∫øp t·ª•c ph√°t tri·ªÉn b·∫£n th√¢n kh√¥ng ng·ª´ng, NƒÉm 2025 anh ƒë√£ c√≥ ƒë∆∞·ª£c ƒëi·ªÅu tuy·ªát v·ªùi nh·∫•t r√πi ·∫°. NƒÉm 2026 s·∫Ω l√† nƒÉm c·ªßa ·ªïn ƒë·ªãnh, b·ª©t ph√° v√† ch√∫c ch√∫ng m√¨nh s·∫Ω ti·∫øp t·ª•c ƒë·ªìng h√†nh c√πng nhau th·∫≠t h·∫°nh ph√∫c v√† c√≥ b∆∞·ªõc ti·∫øn l·ªõn trong cu·ªôc s·ªëng v√† c√¥ng vi·ªác. Ch√∫c cho ch√∫ng m√¨nh s·∫Ω th·∫≠t h·∫°nh ph√∫c v√† c√≥ th√™m nhi·ªÅu nhi·ªÅu k·ªâ ni·ªám c√πng nhau. M·ªçi l·ªùi h·ª©a s·∫Ω th√†nh hi·ªán th·ª±c. Anh t·ª± h√†o v√¨ c√≥ em b√© nhi·ªÅu l·∫Øm ·∫°. Y√™u em r·∫•t nhi·ªÅu ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</p>
    </div>

    <div id="ui-layer">
        <h1 id="main-title">HAPPY NEW YEAR my Bae</h1>
        <div id="mode-indicator">INTERACTIVE JAR</div>
        <div id="touch-hint">SWIPE TO ROTATE &bull; TAP TO SWITCH</div>
    </div>
    <div id="start-overlay">
        <div class="start-btn">CH·∫†M ƒê·ªÇ B·∫ÆT ƒê·∫¶U</div>
        <div class="start-note">‚ô´ HAPPY NEW YEAR</div>
        <div style="font-size: 10px; color: #886666; margin-top: 15px;">36 kho·∫£nh kh·∫Øc ƒëang ch·ªù b·∫°n</div>
    </div>
    <div id="lyrics-container"><span id="lyrics-text">...</span></div>

    <div id="webcam-wrapper">
        <div id="cam-stats">SCAN | AI-LITE</div>
        <canvas id="webcam-canvas"></canvas>
    </div>

    <video id="input_video" style="display:none; transform: scaleX(-1)" playsinline></video>
    <audio id="bg-music" src="" loop></audio>


    <!-- Missing script removed -->
    <!-- <script src="./detect-devtools.js"></script> -->
    <script type='text/javascript'>
        // Bypass for developers (kept for structure, though script removed)
        const keyName = 'key';
        const keyValue = '9ac7ec230e0e4513578f309d6d3579ad';
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import PHOTO_MESSAGES from './messages.js';

        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 800;

        const ENABLE_POST_PROCESSING = true;

        const PARTICLE_RATIO = isMobile ? 0.3 : 1.0;

        const AI_SKIP_FRAMES = isMobile ? 8 : 2;

        // D·ªØ li·ªáu m·∫∑c ƒë·ªãnh - c√°c gi√° tr·ªã fix c·ª©ng
        const FIXED_VALUES = {
            mainTitle: 'Happy New Year',
            textEffectSeq: 'Happy |New Year',
            messages: []
        };

        let NOEL_DATA = {
            mainTitle: FIXED_VALUES.mainTitle,
            secretMessage: 'HAPPY NEW YEAR',
            textEffectSeq: FIXED_VALUES.textEffectSeq,
            messages: FIXED_VALUES.messages,
            images: [],
            song: '/audio.mp3', // Local audio file
            songName: 'Last Christmas', // Fix c·ª©ng
            firework: false,
            LYRICS_DATA: [
  { "time": 5.50, "text": "T·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 7.50, "text": "Ch√†o m·ª´ng nƒÉm m·ªõi ƒë·∫øn" },
  { "time": 9.50, "text": "T·∫°m bi·ªát nh·ªØng ni·ªÅm vui" },
  { "time": 11.50, "text": "V√† c·∫£ nh·ªØng n·ªói bu·ªìn" },
  { "time": 13.50, "text": "Xin c·∫£m ∆°n m·ªçi chuy·ªán ƒë√£ di·ªÖn ra" },
  { "time": 16.50, "text": "D·∫°y cho t√¥i tr∆∞·ªüng th√†nh h∆°n" },
  { "time": 19.50, "text": "B·ªè qua ƒëi h·∫øt nh·ªØng d·ªói h·ªùn" },
  { "time": 23.50, "text": "Ch·ªâ c√≤n v√†i ng√†y n·ªØa th√¥i" },
  { "time": 25.50, "text": "V√†i kho·∫£nh kh·∫Øc n·ªØa th√¥i" },
  { "time": 29.50, "text": "L√† sang m·ªôt nƒÉm m·ªõi r·ªìi" },
  { "time": 32.00, "text": "C√πng nh√¨n l·∫°i nƒÉm ƒë√£ qua" },
  { "time": 34.50, "text": "ƒê∆∞·ª£c v√† m·∫•t nh·ªØng g√¨" },
  { "time": 38.00, "text": "ƒê·ªÉ bi·∫øt m√¨nh thi·∫øu s√≥t chi" },
  { "time": 40.50, "text": "D·∫´u c√≥ nh·ªØng thƒÉng tr·∫ßm qua" },
  { "time": 42.50, "text": "ƒê√¥i khi b·ªù mi ƒë·ªÉ n∆∞·ªõc m·∫Øt r∆°i... ∆∞·ªõt nh√≤a" },
  { "time": 48.00, "text": "V√† th·∫≠t may m·∫Øn khi k·∫ø b√™n" },
  { "time": 51.00, "text": "Lu√¥n c√≥ m·ªçi ng∆∞·ªùi y√™u th∆∞∆°ng" },
  { "time": 55.00, "text": "T·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 57.00, "text": "Ch√†o m·ª´ng nƒÉm m·ªõi ƒë·∫øn" },
  { "time": 59.00, "text": "T·∫°m bi·ªát nh·ªØng ni·ªÅm vui" },
  { "time": 101.00, "text": "V√† c·∫£ nh·ªØng n·ªói bu·ªìn" },
  { "time": 103.50, "text": "Xin c·∫£m ∆°n m·ªçi chuy·ªán ƒë√£ di·ªÖn ra" },
  { "time": 106.50, "text": "D·∫°y cho t√¥i tr∆∞·ªüng th√†nh h∆°n" },
  { "time": 109.50, "text": "B·ªè qua ƒëi h·∫øt nh·ªØng d·ªói h·ªùn" },
  { "time": 112.00, "text": "T·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 114.00, "text": "Ch√†o m·ª´ng nƒÉm m·ªõi ƒë·∫øn" },
  { "time": 116.00, "text": "Th·∫ßm c·∫ßu ch√∫c b√¨nh an" },
  { "time": 118.00, "text": "S·ª©c kh·ªèe m√£i v·ªØng b·ªÅn" },
  { "time": 120.50, "text": "NƒÉm m·ªõi th√™m m·ªôt tu·ªïi m·∫°nh m·∫Ω h∆°n" },
  { "time": 123.50, "text": "Kh√¥ng c√≤n bu·ªìn phi·ªÅn c√¥ ƒë∆°n" },
  { "time": 126.50, "text": "Gi·ªØ m√£i tr√™n m√¥i n·ª• c∆∞·ªùi t∆∞∆°i" },
  { "time": 129.50, "text": "V√† ƒë√¥i m·∫Øt r·∫°ng ng·ªùi" },
  { "time": 146.50, "text": "Ch·ªâ c√≤n v√†i ng√†y n·ªØa th√¥i" },
  { "time": 148.50, "text": "V√†i kho·∫£nh kh·∫Øc n·ªØa th√¥i" },
  { "time": 152.50, "text": "L√† sang m·ªôt nƒÉm m·ªõi r·ªìi" },
  { "time": 155.00, "text": "C√πng nh√¨n l·∫°i nƒÉm ƒë√£ qua" },
  { "time": 157.50, "text": "ƒê∆∞·ª£c v√† m·∫•t nh·ªØng g√¨" },
  { "time": 161.00, "text": "ƒê·ªÉ bi·∫øt m√¨nh thi·∫øu s√≥t chi" },
  { "time": 163.50, "text": "D·∫´u c√≥ nh·ªØng thƒÉng tr·∫ßm qua" },
  { "time": 165.50, "text": "ƒê√¥i khi b·ªù mi ƒë·ªÉ n∆∞·ªõc m·∫Øt r∆°i... ∆∞·ªõt nh√≤a" },
  { "time": 171.00, "text": "V√† th·∫≠t may m·∫Øn khi k·∫ø b√™n" },
  { "time": 174.00, "text": "Lu√¥n c√≥ m·ªçi ng∆∞·ªùi y√™u th∆∞∆°ng" },
  { "time": 177.50, "text": "T·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 180.00, "text": "Ch√†o m·ª´ng nƒÉm m·ªõi ƒë·∫øn" },
  { "time": 182.00, "text": "T·∫°m bi·ªát nh·ªØng ni·ªÅm vui" },
  { "time": 184.00, "text": "V√† c·∫£ nh·ªØng n·ªói bu·ªìn" },
  { "time": 186.50, "text": "Xin c·∫£m ∆°n m·ªçi chuy·ªán ƒë√£ di·ªÖn ra" },
  { "time": 189.50, "text": "D·∫°y cho t√¥i tr∆∞·ªüng th√†nh h∆°n" },
  { "time": 192.50, "text": "B·ªè qua ƒëi h·∫øt nh·ªØng d·ªói h·ªùn" },
  { "time": 195.00, "text": "T·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 197.00, "text": "Ch√†o m·ª´ng nƒÉm m·ªõi ƒë·∫øn" },
  { "time": 199.00, "text": "Th·∫ßm c·∫ßu ch√∫c b√¨nh an" },
  { "time": 201.00, "text": "S·ª©c kh·ªèe m√£i v·ªØng b·ªÅn" },
  { "time": 203.50, "text": "NƒÉm m·ªõi th√™m m·ªôt tu·ªïi m·∫°nh m·∫Ω h∆°n" },
  { "time": 206.50, "text": "Kh√¥ng c√≤n bu·ªìn phi·ªÅn c√¥ ƒë∆°n" },
  { "time": 209.50, "text": "Gi·ªØ m√£i tr√™n m√¥i n·ª• c∆∞·ªùi t∆∞∆°i" },
  { "time": 212.50, "text": "V√† ƒë√¥i m·∫Øt r·∫°ng ng·ªùi" },
  { "time": 252.50, "text": "T·∫°m bi·ªát, t·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 256.50, "text": "T·∫°m bi·ªát, t·∫°m bi·ªát..." },
  { "time": 300.50, "text": "T·∫°m bi·ªát, t·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 304.50, "text": "T·∫°m bi·ªát, t·∫°m bi·ªát..." },
  { "time": 308.50, "text": "T·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 310.50, "text": "Ch√†o m·ª´ng nƒÉm m·ªõi ƒë·∫øn" },
  { "time": 312.50, "text": "T·∫°m bi·ªát nh·ªØng ni·ªÅm vui" },
  { "time": 314.50, "text": "V√† c·∫£ nh·ªØng n·ªói bu·ªìn" },
  { "time": 317.00, "text": "Xin c·∫£m ∆°n m·ªçi chuy·ªán ƒë√£ di·ªÖn ra" },
  { "time": 320.00, "text": "D·∫°y cho t√¥i tr∆∞·ªüng th√†nh h∆°n" },
  { "time": 323.00, "text": "B·ªè qua ƒëi h·∫øt nh·ªØng d·ªói h·ªùn" },
  { "time": 325.50, "text": "T·∫°m bi·ªát nƒÉm c≈© qua" },
  { "time": 327.50, "text": "Ch√†o m·ª´ng nƒÉm m·ªõi ƒë·∫øn" },
  { "time": 329.50, "text": "Th·∫ßm c·∫ßu ch√∫c b√¨nh an" },
  { "time": 331.50, "text": "S·ª©c kh·ªèe m√£i v·ªØng b·ªÅn" },
  { "time": 334.00, "text": "NƒÉm m·ªõi th√™m m·ªôt tu·ªïi m·∫°nh m·∫Ω h∆°n" },
  { "time": 337.00, "text": "Kh√¥ng c√≤n bu·ªìn phi·ªÅn c√¥ ƒë∆°n" },
  { "time": 340.00, "text": "Gi·ªØ m√£i tr√™n m√¥i n·ª• c∆∞·ªùi t∆∞∆°i" },
  { "time": 343.00, "text": "V√† ƒë√¥i m·∫Øt r·∫°ng ng·ªùi" }
]
        };

        // H√†m load d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c s·ª≠a l·∫°i ƒë·ªÉ ch·∫°y Offline/Online v·ªõi remote assets
        async function loadNoelData() {
            console.log('‚ÑπÔ∏è ƒêang ch·∫°y ch·∫ø ƒë·ªô v·ªõi assets local');

            // 2. Load 36 ·∫£nh c·ªë ƒë·ªãnh t·ª´ th∆∞ m·ª•c Img
            // 2. Load 36 ·∫£nh c·ªë ƒë·ªãnh t·ª´ th∆∞ m·ª•c Img
            if (NOEL_DATA.images.length === 0) {
                // Danh s√°ch 36 ·∫£nh theo t√™n file th·ª±c t·∫ø trong folder (c·∫≠p nh·∫≠t ch√≠nh x√°c 100%)
                const imageFiles = [
                    '1.png', '2.jpg', '3.png', '4.jpg', '5.png', '6.png', '7.png', '8.jpg', '9.jpg', '10.jpg',
                    '11.jpg', '12.jpg', '13.jpg', '14.png', '15.jpg', '16.jpg', '17.jpg', '18.jpg', '19.jpg', '20.png',
                    '21.jpg', '22.jpg', '23.jpg', '24.jpg', '25.jpg', '26.jpg', '27.jpg', '28.jpg', '29.jpg', '30.jpg',
                    '31.jpg', '32.jpg', '33.webp', '34.jpg', '35.jpg', '36.png'
                ];
                NOEL_DATA.images = imageFiles.map(f => `/Img/${f}`);
            }

            // 3. C√°c c√†i ƒë·∫∑t kh√°c (b·∫°n c√≥ th·ªÉ s·ª≠a ch·ªØ ·ªü ƒë√¢y)
            NOEL_DATA.secretMessage = 'HAPPY NEW YEAR'; // L·ªùi ch√∫c b√≠ m·∫≠t
            NOEL_DATA.firework = true; // B·∫≠t ph√°o hoa (true: b·∫≠t, false: t·∫Øt)

            // Gi·∫£ l·∫≠p ƒë·ªô tr·ªÖ nh·ªè ƒë·ªÉ gi·ªëng nh∆∞ ƒëang load (t√πy ch·ªçn)
            await new Promise(r => setTimeout(r, 500));
        }

        // S·ªë l∆∞·ª£ng ·∫£nh c·ªë ƒë·ªãnh l√† 36
        let TOTAL_PHOTOS = 36;
        let LYRICS_DATA = NOEL_DATA.LYRICS_DATA;

        // Bi·∫øn theo d√µi ·∫£nh hi·ªán t·∫°i ƒë·ªÉ xem tu·∫ßn t·ª±
        let currentPhotoIndex = 0;

        // H√†m random 10 ·∫£nh th√†nh 20 ·∫£nh, ƒë·∫£m b·∫£o kh√¥ng l·∫∑p l·∫°i g·∫ßn nhau
        function randomizeImages(images, targetCount) {
            if (images.length === 0) return [];
            if (images.length >= targetCount) return images.slice(0, targetCount);

            const result = new Array(targetCount).fill(null);
            const minDistance = Math.max(2, Math.floor(targetCount / images.length)); // Kho·∫£ng c√°ch t·ªëi thi·ªÉu gi·ªØa 2 ·∫£nh gi·ªëng nhau

            // T·∫°o danh s√°ch c√°c ·∫£nh c·∫ßn ƒë·∫∑t (m·ªói ·∫£nh s·∫Ω xu·∫•t hi·ªán ~targetCount/images.length l·∫ßn)
            const imagesToPlace = [];
            const timesPerImage = Math.floor(targetCount / images.length);
            const remainder = targetCount % images.length;

            images.forEach((img, index) => {
                const count = timesPerImage + (index < remainder ? 1 : 0);
                for (let i = 0; i < count; i++) {
                    imagesToPlace.push({ img, originalIndex: index });
                }
            });

            // Shuffle danh s√°ch ·∫£nh
            for (let i = imagesToPlace.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [imagesToPlace[i], imagesToPlace[j]] = [imagesToPlace[j], imagesToPlace[i]];
            }

            // ƒê·∫∑t t·ª´ng ·∫£nh v√†o v·ªã tr√≠ ph√π h·ª£p
            imagesToPlace.forEach(({ img, originalIndex }) => {
                let bestPosition = -1;
                let maxMinDistance = -1;

                // T√¨m v·ªã tr√≠ t·ªët nh·∫•t (c√°ch xa nh·∫•t c√°c ·∫£nh c√πng lo·∫°i ƒë√£ ƒë·∫∑t)
                for (let pos = 0; pos < targetCount; pos++) {
                    if (result[pos] !== null) continue; // V·ªã tr√≠ ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t

                    // T√≠nh kho·∫£ng c√°ch t·ªëi thi·ªÉu ƒë·∫øn c√°c ·∫£nh c√πng lo·∫°i ƒë√£ ƒë·∫∑t
                    let minDist = Infinity;
                    for (let i = 0; i < targetCount; i++) {
                        if (result[i] === img) {
                            const dist = Math.min(
                                Math.abs(i - pos),
                                Math.abs(i - pos + targetCount),
                                Math.abs(i - pos - targetCount)
                            );
                            minDist = Math.min(minDist, dist);
                        }
                    }

                    // N·∫øu ch∆∞a c√≥ ·∫£nh c√πng lo·∫°i n√†o, kho·∫£ng c√°ch l√† v√¥ c√πng
                    if (minDist === Infinity) minDist = targetCount;

                    // ∆Øu ti√™n v·ªã tr√≠ c√≥ kho·∫£ng c√°ch l·ªõn nh·∫•t v√† >= minDistance
                    if (minDist >= minDistance && minDist > maxMinDistance) {
                        maxMinDistance = minDist;
                        bestPosition = pos;
                    }
                }

                // N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c v·ªã tr√≠ l√Ω t∆∞·ªüng, t√¨m v·ªã tr√≠ c√≥ kho·∫£ng c√°ch l·ªõn nh·∫•t
                if (bestPosition === -1) {
                    for (let pos = 0; pos < targetCount; pos++) {
                        if (result[pos] !== null) continue;

                        let minDist = Infinity;
                        for (let i = 0; i < targetCount; i++) {
                            if (result[i] === img) {
                                const dist = Math.min(
                                    Math.abs(i - pos),
                                    Math.abs(i - pos + targetCount),
                                    Math.abs(i - pos - targetCount)
                                );
                                minDist = Math.min(minDist, dist);
                            }
                        }
                        if (minDist === Infinity) minDist = targetCount;

                        if (minDist > maxMinDistance) {
                            maxMinDistance = minDist;
                            bestPosition = pos;
                        }
                    }
                }

                // N·∫øu v·∫´n kh√¥ng t√¨m ƒë∆∞·ª£c, ƒë·∫∑t v√†o v·ªã tr√≠ ƒë·∫ßu ti√™n c√≤n tr·ªëng
                if (bestPosition === -1) {
                    bestPosition = result.findIndex(x => x === null);
                }

                if (bestPosition !== -1) {
                    result[bestPosition] = img;
                }
            });

            return result;
        }

        const zFactor = isMobile ? 1.4 : 1.0;
        const SCENE_CONFIG = {
            scaleFar: isMobile ? 8.0 : 10.00,
            posFar: { x: 0.0, y: isMobile ? -0.2 : -0.6 },
            camZFar: 7.7 * zFactor,
            scaleNear: 10.00,
            posNear: { x: 0.0, y: -0.7 },
            camZNear: 2.5,
            zoomSpeed: 0.1,
            rotateSpeed: 0.08
        };

        const LAYERS = [
            { id: 'inner_snow', shape: 'Snowflake', count: Math.floor(1200 * PARTICLE_RATIO), opacity: 0.9, color: '#ffffff', speed: 0.0005, size: 0.06, radius: 0.48, startY: 1.1, endY: -0.3, drift: 0.01, twinkle: false, rotateWithJar: true },
            { id: 'snow_main', shape: 'Snowflake', count: Math.floor(500 * PARTICLE_RATIO), opacity: 0.9, color: '#e0ffff', speed: 0.0010, size: 0.18, radius: 5.0, startY: 7.0, endY: -6.0, drift: 0.05, twinkle: true, rotateWithJar: true },
            { id: 'gold_dust', shape: 'Circle', count: Math.floor(500 * PARTICLE_RATIO), opacity: 0.8, color: '#ffcc00', speed: 0.0006, size: 0.03, radius: 4.5, startY: 6.0, endY: -4.0, drift: 0.08, twinkle: true, rotateWithJar: true }
        ];

        let scene, camera, renderer, composer, bloomPass, mixer, particleSystems = {}, textureCache = {}, polaroidTextures = [], polaroidGroup, clock = new THREE.Clock(), bgParticleGroup;
        let isGalleryMode = true, lastGesture = 'NONE', isZoomedIn = false, lastSwitchTime = 0, lastDropTime = 0, jarOffsetY = 0, inspectedPhoto = null;
        let carModel; // Keep variable but won't load it
        let viewedPhotos = new Set(); // Track viewed photos
        let autoCloseTimer = null; // Timer for auto-closing photos
        let currentMessageEl = null; // Element hi·ªÉn th·ªã l·ªùi ch√∫c
        const SWITCH_COOLDOWN = 1.0;

        const STATE = {
            hand: { detected: false, x: 0.5, y: 0.5, gesture: 'NONE' },
            targetRotation: { x: 0, y: 0 },
            currentRotation: { x: 0, y: 0 }
        };

        let isFireworkMode = false;

        let touchStartX = 0, touchStartY = 0;
        let isTouching = false;
        let touchLastTap = 0;

        const FW_CONFIG = { particleCount: isMobile ? 60 : 500, explosionRadius: 25, friction: 0.98, gravity: 0.04, focalLength: 800, autoFireRate: isMobile ? 120 : 100 };
        let fwCanvas, fwCtx, fwWidth, fwHeight, fwCx, fwCy;
        let fwParticles = [];
        let fwFireworks = [];

        function initFireworkCanvas() {
            fwCanvas = document.getElementById('firework-canvas'); fwCtx = fwCanvas.getContext('2d');
            resizeFw(); window.addEventListener('resize', resizeFw);
        }
        function resizeFw() {
            fwWidth = window.innerWidth; fwHeight = window.innerHeight;
            fwCanvas.width = fwWidth; fwCanvas.height = fwHeight;
            fwCx = fwWidth / 2; fwCy = fwHeight / 2;
        }
        const fwRandom = (min, max) => Math.random() * (max - min) + min;

        class Particle3D {
            constructor(x, y, z, color) {
                this.x = x; this.y = y; this.z = z; this.color = color; this.size = fwRandom(1, 3);
                const theta = Math.random() * Math.PI * 2; const phi = Math.acos((Math.random() * 2) - 1);
                const speed = fwRandom(5, FW_CONFIG.explosionRadius);
                this.vx = speed * Math.sin(phi) * Math.cos(theta);
                this.vy = speed * Math.sin(phi) * Math.sin(theta);
                this.vz = speed * Math.cos(phi);
                this.alpha = 1; this.decay = fwRandom(0.015, 0.03);
                this.last2Dx = 0; this.last2Dy = 0; this.hasMoved = false;
            }
            update() {
                this.vx *= FW_CONFIG.friction; this.vy *= FW_CONFIG.friction; this.vz *= FW_CONFIG.friction;
                this.vy += FW_CONFIG.gravity;
                this.x += this.vx; this.y += this.vy; this.z += this.vz;
                this.alpha -= this.decay;
            }
            draw() {
                if (this.alpha <= 0.1) return;
                const scale = FW_CONFIG.focalLength / (FW_CONFIG.focalLength + this.z);
                const screenX = fwCx + this.x * scale; const screenY = fwCy + this.y * scale;
                if (scale < 0) return;
                const currentSize = this.size * scale;
                if (this.hasMoved) {
                    fwCtx.beginPath(); fwCtx.strokeStyle = this.color; fwCtx.lineWidth = currentSize; fwCtx.globalAlpha = this.alpha * 0.7;
                    fwCtx.moveTo(this.last2Dx, this.last2Dy); fwCtx.lineTo(screenX, screenY); fwCtx.stroke();
                }
                this.last2Dx = screenX; this.last2Dy = screenY; this.hasMoved = true;
            }
        }

        class FireworkSeed {
            constructor() {
                this.x = fwRandom(fwWidth * 0.3, fwWidth * 0.7); this.y = fwHeight;
                this.targetY = fwRandom(fwHeight * 0.15, fwHeight * 0.35);
                this.speed = fwRandom(8, 12); this.angle = -Math.PI / 2;
                this.vx = Math.cos(this.angle) * this.speed; this.vy = Math.sin(this.angle) * this.speed;
                this.exploded = false;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.vy += 0.1;
                if (this.vy >= 0 || this.y <= this.targetY) { this.exploded = true; this.explode(); }
            }
            draw() {
                fwCtx.globalAlpha = 1; fwCtx.strokeStyle = '#FFD700'; fwCtx.lineWidth = 2;
                fwCtx.beginPath(); fwCtx.moveTo(this.x, this.y); fwCtx.lineTo(this.x, this.y + 10); fwCtx.stroke();
            }
            explode() {
                const originX = this.x - fwCx; const originY = this.y - fwCy; const originZ = fwRandom(-100, 100);
                // Random hue for colorful fireworks (0-360)
                const hueBase = fwRandom(0, 360);
                for (let i = 0; i < FW_CONFIG.particleCount; i++) {
                    const lightness = fwRandom(50, 80); const color = `hsl(${hueBase}, 100%, ${lightness}%)`;
                    fwParticles.push(new Particle3D(originX, originY, originZ, color));
                }
            }
        }

        function loopFireworks() {
            if (!isFireworkMode || !NOEL_DATA.firework) return;
            fwCtx.globalCompositeOperation = 'source-over';
            fwCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            fwCtx.fillRect(0, 0, fwWidth, fwHeight);
            fwCtx.globalCompositeOperation = 'lighter';

            if (Math.random() * FW_CONFIG.autoFireRate < 2) fwFireworks.push(new FireworkSeed());

            for (let i = fwFireworks.length - 1; i >= 0; i--) {
                fwFireworks[i].update(); fwFireworks[i].draw();
                if (fwFireworks[i].exploded) fwFireworks.splice(i, 1);
            }
            for (let i = fwParticles.length - 1; i >= 0; i--) {
                fwParticles[i].update(); fwParticles[i].draw();
                if (fwParticles[i].alpha <= 0) fwParticles.splice(i, 1);
            }
            requestAnimationFrame(loopFireworks);
        }

        function triggerFireworkMode() {
            if (isFireworkMode) return;
            isFireworkMode = true;

            const tl = gsap.timeline();
            // Ch·ªâ hi·ªÉn th·ªã firework canvas n·∫øu firework = true
            if (NOEL_DATA.firework) {
                document.getElementById('firework-canvas').style.display = 'block';
            }
            tl.to('#black-void', { opacity: 1, duration: 1.5 });
            tl.to('#ui-layer', { opacity: 0, duration: 0.5 }, 0);
            tl.to('#lyrics-container', { opacity: 0, duration: 0.5 }, 0);
            // Hi·ªÉn th·ªã secret message tr∆∞·ªõc
            tl.to('#secret-message', { opacity: 1, duration: 2, scale: 1.1, ease: "power2.out" }, 0.5);
            // Sau ƒë√≥ hi·ªÉn th·ªã ending section v·ªõi l·ªùi ch√∫c
            tl.to('#ending-section', { opacity: 1, duration: 2, ease: "power2.out" }, 1.5);

            if (polaroidGroup) {
                polaroidGroup.children.forEach(p => {
                    tl.to(p.position, { x: 0, y: 0, z: 0, duration: 1, ease: "back.in(1.7)" }, 0);
                    tl.to(p.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "back.in(1.7)" }, 0);
                });
            }
            if (carModel) tl.to(carModel.scale, { x: 0, y: 0, z: 0, duration: 1, ease: "back.in(1.7)" }, 0);

            // Ch·ªâ ch·∫°y animation ph√°o hoa n·∫øu firework = true
            if (NOEL_DATA.firework) {
                setTimeout(() => { loopFireworks(); }, 800);
            }
        }

        function exitFireworkMode() {
            if (!isFireworkMode) return;
            isFireworkMode = false;
            const tl = gsap.timeline();
            tl.to('#secret-message', { opacity: 0, duration: 0.5, scale: 1 }, 0);
            tl.to('#ending-section', { opacity: 0, duration: 0.5 }, 0);
            tl.to('#black-void', { opacity: 0, duration: 1 });
            tl.to('#ui-layer', { opacity: 1, duration: 1 }, 0);

            fwCtx.clearRect(0, 0, fwWidth, fwHeight);
            fwParticles = []; fwFireworks = [];
            document.getElementById('firework-canvas').style.display = 'none';

            if (carModel) tl.to(carModel.scale, { x: SCENE_CONFIG.scaleFar, y: SCENE_CONFIG.scaleFar, z: SCENE_CONFIG.scaleFar, duration: 1.5, ease: "elastic.out(1, 0.5)" }, 0.5);

            if (polaroidGroup) {
                polaroidGroup.children.forEach(p => {
                    p.position.copy(p.userData.startPos); p.scale.set(1, 1, 1); p.material.opacity = 0;
                });
            }
            isGalleryMode = false;
            document.getElementById('mode-indicator').innerText = "MODE: JAR CONTROL";
            document.getElementById('mode-indicator').style.color = "rgba(255, 215, 0, 0.7)";
            gsap.to(camera.position, { z: SCENE_CONFIG.camZFar, duration: 1.5 });
            gsap.to(window, { duration: 1.2, jarOffsetY: 0 });
        }

        async function init() {
            // Load d·ªØ li·ªáu t·ª´ API tr∆∞·ªõc khi kh·ªüi t·∫°o
            await loadNoelData();

            // C·∫≠p nh·∫≠t LYRICS_DATA sau khi load
            LYRICS_DATA = NOEL_DATA.LYRICS_DATA;

            // N·∫øu c√≥ ·∫£nh t·ª´ API v√† c√≥ ƒë√∫ng 10 ·∫£nh, s·∫Ω random th√†nh 20 ·∫£nh
            // TOTAL_PHOTOS lu√¥n l√† 20 (ho·∫∑c 8 tr√™n mobile) ƒë·ªÉ render

            // C·∫≠p nh·∫≠t UI
            const mainTitleEl = document.getElementById('main-title');
            const secretMessageEl = document.getElementById('secret-message');
            const bgMusicEl = document.getElementById('bg-music');
            const startNoteEl = document.querySelector('.start-note');

            if (mainTitleEl) mainTitleEl.textContent = NOEL_DATA.mainTitle;
            if (secretMessageEl) secretMessageEl.textContent = NOEL_DATA.secretMessage;
            if (startNoteEl && NOEL_DATA.songName) {
                startNoteEl.textContent = `‚ô´ ${NOEL_DATA.songName}`;
            }
            if (bgMusicEl && NOEL_DATA.song) {
                bgMusicEl.src = NOEL_DATA.song.startsWith('http') ? NOEL_DATA.song : NOEL_DATA.song;
            } else if (bgMusicEl) {
                bgMusicEl.src = '/audio.mp3';
            }

            const overlay = document.getElementById('start-overlay');
            const audio = document.getElementById('bg-music');
            const startBtn = document.querySelector('.start-btn');

            startBtn.addEventListener('click', async () => {
                overlay.style.opacity = 0;
                setTimeout(() => overlay.remove(), 500);
                initTouchControls();
                // Set audio source t·ª´ d·ªØ li·ªáu ƒë√£ load
                if (NOEL_DATA.song) {
                    audio.src = NOEL_DATA.song.startsWith('http') ? NOEL_DATA.song : NOEL_DATA.song;
                } else {
                    audio.src = '/audio.mp3';
                }
                audio.play().catch(e => { console.log("Audio Error:", e); });
            });

            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, SCENE_CONFIG.camZFar);

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.0));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.8;

            container.appendChild(renderer.domElement);

            if (ENABLE_POST_PROCESSING) {
                const renderScene = new RenderPass(scene, camera);
                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);

                const bloomRes = new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2);
                bloomPass = new UnrealBloomPass(bloomRes, 1.5, 0.4, 0.85);
                // TƒÉng threshold l√™n 1.2 ƒë·ªÉ ·∫£nh kh√¥ng b·ªã bloom (ch·ªâ particles s√°ng m·ªõi glow)
                bloomPass.threshold = 1.2; bloomPass.strength = 0.4; bloomPass.radius = 0.3;
                composer.addPass(bloomPass);
            }

            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;

            const dirLight = new THREE.DirectionalLight(0xffeebb, 1.2);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            const redLight = new THREE.PointLight(0xff0000, 0.5, 20); redLight.position.set(-5, 2, 0); scene.add(redLight);
            scene.add(new THREE.AmbientLight(0x404040, 1.0));

            loadTextures(); setupBackgroundParticles();
            // Ch·ªâ load v√† t·∫°o polaroid n·∫øu c√≥ ·∫£nh
            if (NOEL_DATA.images.length > 0) {
                loadPolaroidTextures();
                createPolaroids();
            }
            LAYERS.forEach(createLayerSystem);

            // Removed Car Model Loading per user request to focus on Gallery
            /*
            new GLTFLoader().load('https://soncuc.love/car.glb', (gltf) => {
                carModel = gltf.scene; carModel.scale.setScalar(SCENE_CONFIG.scaleFar);
                carModel.position.set(SCENE_CONFIG.posFar.x, SCENE_CONFIG.posFar.y, 0);
                carModel.position.z = -0.5; carModel.rotation.set(0,0,0);
                if (gltf.animations.length) { mixer = new THREE.AnimationMixer(carModel); mixer.clipAction(gltf.animations[0]).play(); }
                scene.add(carModel);
            });
            */
            // Create a center point reference if needed, or just rotate group around 0,0,0

            initFireworkCanvas();
            initHandTracking();

            // Force Gallery Mode UI v·ªõi s·ªë ƒë·∫øm ·∫£nh
            const indicator = document.getElementById('mode-indicator');
            if (indicator) {
                indicator.innerText = `M·ªû TAY ƒê·ªÇ XEM ·∫¢NH (0/${TOTAL_PHOTOS})`;
                indicator.style.color = "#FFD700";
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (composer) composer.setSize(window.innerWidth, window.innerHeight);
                resizeFw();
            });
            animate();
        }

        function initTouchControls() {
            const el = document.getElementById('canvas-container');

            el.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; isTouching = true;
                }
            }, { passive: false });

            el.addEventListener('touchmove', (e) => {
                if (!isTouching || isFireworkMode) return;
                e.preventDefault();
                if (e.touches.length === 1) {
                    const x = e.touches[0].clientX; const y = e.touches[0].clientY;
                    const dx = (x - touchStartX) * 0.005; const dy = (y - touchStartY) * 0.005;

                    if (!isGalleryMode) {
                        STATE.targetRotation.x += dy; STATE.targetRotation.y += dx;
                        STATE.currentRotation.x = STATE.targetRotation.x; STATE.currentRotation.y = STATE.targetRotation.y;
                        if (carModel) { carModel.rotation.y = STATE.currentRotation.y; carModel.rotation.x = STATE.currentRotation.x; }
                    }
                    touchStartX = x; touchStartY = y;
                }
            }, { passive: false });

            el.addEventListener('touchend', (e) => {
                isTouching = false;
                const now = Date.now();
                if (now - touchLastTap < 300) toggleMode();
                touchLastTap = now;
            });

            let longPressTimer;
            el.addEventListener('touchstart', () => {
                longPressTimer = setTimeout(() => {
                    // Cho ph√©p trigger firework mode ngay c·∫£ khi kh√¥ng c√≥ ·∫£nh
                    triggerFireworkMode();
                }, 1500);
            });
            el.addEventListener('touchend', () => clearTimeout(longPressTimer));
        }

        // H√†m h·ªó tr·ª£ xu·ªëng d√≤ng text tr√™n Canvas
        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            const lines = [];

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);

            // V·∫Ω t·ª´ng d√≤ng
            // CƒÉn ch·ªânh y ƒë·ªÉ block text n·∫±m gi·ªØa kho·∫£ng tr·ªëng bottom
            // y truy·ªÅn v√†o l√† d√≤ng ƒë·∫ßu ti√™n.
            for (let k = 0; k < lines.length; k++) {
                ctx.fillText(lines[k], x, y + (k * lineHeight));
            }
        }

        function loadPolaroidTextures() {
            // Load 36 ·∫£nh c·ªë ƒë·ªãnh t·ª´ NOEL_DATA.images
            if (!NOEL_DATA.images || NOEL_DATA.images.length === 0) {
                console.log('‚ÑπÔ∏è Kh√¥ng c√≥ ·∫£nh, b·ªè qua load polaroid textures');
                return;
            }

            const imgLoader = new THREE.ImageLoader();
            imgLoader.crossOrigin = 'anonymous';

            NOEL_DATA.images.forEach((imageUrl, index) => {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 650; // TƒÉng chi·ªÅu cao x√≠u ƒë·ªÉ c√≥ ch·ªó cho text nhi·ªÅu d√≤ng
                const ctx = canvas.getContext('2d');

                // Background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 512, 650);
                // Placeholder ·∫£nh
                ctx.fillStyle = '#e0e0e0';
                ctx.fillRect(20, 20, 472, 472);

                const texture = new THREE.CanvasTexture(canvas);
                texture.colorSpace = THREE.SRGBColorSpace;
                polaroidTextures.push(texture);

                imgLoader.load(imageUrl, (image) => {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, 512, 650);
                    ctx.drawImage(image, 20, 20, 472, 472);

                    // L·∫•y l·ªùi ch√∫c
                    const messageData = PHOTO_MESSAGES.find(m => m.id === index + 1);
                    const messageText = messageData ? messageData.message : `Moment ${index + 1}`;

                    // Config font - Be Vietnam Pro cho ti·∫øng Vi·ªát
                    ctx.fillStyle = '#000';
                    // T·ª± ƒë·ªông gi·∫£m size n·∫øu text qu√° d√†i
                    let fontSize = 28;
                    if (messageText.length > 50) fontSize = 22;

                    ctx.font = `bold ${fontSize}px 'Be Vietnam Pro', sans-serif`; // Font h·ªó tr·ª£ ti·∫øng Vi·ªát
                    ctx.textAlign = 'center';

                    // V·∫Ω message wrap text
                    // V·ªã tr√≠ y b·∫Øt ƒë·∫ßu t·ª´ kho·∫£ng 520
                    wrapText(ctx, messageText, 256, 530, 460, fontSize + 8);

                    texture.needsUpdate = true;
                }, undefined, () => {
                    // Error fallback
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, 512, 650);
                    ctx.fillStyle = '#ffeebb';
                    ctx.fillRect(20, 20, 472, 472);
                    ctx.fillStyle = '#800000';
                    ctx.font = 'bold 32px Cinzel';
                    ctx.textAlign = 'center';
                    ctx.fillText('NO IMAGE', 256, 270);
                    texture.needsUpdate = true;
                });
            });
        }

        function updateLyrics() {
            const audio = document.getElementById('bg-music'); const lyricBox = document.getElementById('lyrics-text');
            if (!audio || audio.paused || LYRICS_DATA.length === 0) return;
            const t = audio.currentTime; let currentLine = "";
            for (let i = 0; i < LYRICS_DATA.length; i++) { if (t >= LYRICS_DATA[i].time) { if (i === LYRICS_DATA.length - 1 || t < LYRICS_DATA[i + 1].time) { currentLine = LYRICS_DATA[i].text; break; } } }
            if (lyricBox.innerText !== currentLine) lyricBox.innerText = currentLine;
        }

        function loadTextures() {
            // T·∫°o texture snowflake b·∫±ng Canvas thay v√¨ load file (fix missing snow.png)
            const snowCanvas = document.createElement('canvas');
            snowCanvas.width = 64; snowCanvas.height = 64;
            const snowCtx = snowCanvas.getContext('2d');
            snowCtx.fillStyle = 'rgba(0,0,0,0)';
            snowCtx.fillRect(0, 0, 64, 64);
            // V·∫Ω b√¥ng tuy·∫øt ƒë∆°n gi·∫£n
            snowCtx.strokeStyle = 'white';
            snowCtx.lineWidth = 2;
            snowCtx.lineCap = 'round';
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                snowCtx.save();
                snowCtx.translate(32, 32);
                snowCtx.rotate(angle);
                snowCtx.beginPath();
                snowCtx.moveTo(0, 0);
                snowCtx.lineTo(0, -24);
                snowCtx.moveTo(0, -12);
                snowCtx.lineTo(-6, -18);
                snowCtx.moveTo(0, -12);
                snowCtx.lineTo(6, -18);
                snowCtx.stroke();
                snowCtx.restore();
            }
            textureCache['Snowflake'] = new THREE.CanvasTexture(snowCanvas);

            const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64; const ctx = cvs.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 30); g.addColorStop(0, 'rgba(255,255,255,1)'); g.addColorStop(0.4, 'rgba(255,255,255,0.5)'); g.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = g; ctx.fillRect(0, 0, 64, 64); textureCache['Circle'] = new THREE.CanvasTexture(cvs);
        }

        function setupBackgroundParticles() {
            const count = isMobile ? 200 : 1500;
            bgParticleGroup = new THREE.Group(); bgParticleGroup.position.z = -12; scene.add(bgParticleGroup);
            const starGeo = new THREE.BufferGeometry(); const starPos = [];
            for (let i = 0; i < count; i++) starPos.push((Math.random() - 0.5) * 180, (Math.random() - 0.5) * 120, (Math.random() - 0.5) * 60);
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            bgParticleGroup.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffeebb, size: 0.15, transparent: true, opacity: 0.8 })));
        }

        function updateBackgroundParticles(time, dt) {
            if (!bgParticleGroup) return;
            bgParticleGroup.rotation.z = Math.sin(time * 0.02) * 0.02; bgParticleGroup.rotation.y = Math.sin(time * 0.03) * 0.03;
        }

        function createPolaroids() {
            // Ch·ªâ t·∫°o polaroid n·∫øu c√≥ ·∫£nh
            if (NOEL_DATA.images.length === 0) {
                console.log('‚ÑπÔ∏è Kh√¥ng c√≥ ·∫£nh, b·ªè qua t·∫°o polaroid gallery');
                polaroidGroup = null;
                return;
            }

            polaroidGroup = new THREE.Group(); const geometry = new THREE.PlaneGeometry(1.5, 1.95); // Larger photos for slideshow feel
            const count = NOEL_DATA.images.length;
            const radius = 8.0; // Wider radius

            for (let i = 0; i < count; i++) {
                const material = new THREE.MeshBasicMaterial({ map: polaroidTextures[i % polaroidTextures.length], side: THREE.DoubleSide, transparent: true, opacity: 0 });
                const polaroid = new THREE.Mesh(geometry, material);

                // Arrange in a circle
                const theta = (i / count) * Math.PI * 2;
                const x = radius * Math.sin(theta);
                const z = radius * Math.cos(theta);

                // Position for Gallery Mode
                const targetPos = new THREE.Vector3(x, 0, z);
                // Look at center (camera)
                const targetRotY = Math.atan2(x, z) + Math.PI; // Face inward towards viewer? Or outward? 
                // To face camera when at back: atan2(x, z). 

                polaroid.userData = {
                    targetPos: targetPos,
                    startPos: targetPos, // Start right in position
                    floatOffset: Math.random() * 100,
                    targetRot: { x: 0, y: targetRotY, z: 0 },
                    originalIndex: i
                };

                polaroid.rotation.y = targetRotY;
                polaroid.position.copy(targetPos);
                polaroid.visible = true;
                polaroid.material.opacity = 1; // Show immediately
                polaroidGroup.add(polaroid);
            }
            scene.add(polaroidGroup);
        }

        function createLayerSystem(config) {
            const geo = new THREE.BufferGeometry(); const pos = [], vel = [], off = [];
            for (let i = 0; i < config.count; i++) {
                const r = config.radius * Math.sqrt(Math.random()); const theta = Math.random() * 2 * Math.PI;
                pos.push(r * Math.cos(theta), config.startY - Math.random() * (config.startY - config.endY), r * Math.sin(theta));
                vel.push((Math.random() * 0.4) + 0.6); off.push(Math.random() * 100);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3)); geo.setAttribute('velocity', new THREE.Float32BufferAttribute(vel, 1)); geo.setAttribute('offset', new THREE.Float32BufferAttribute(off, 1));
            const mat = new THREE.PointsMaterial({ size: config.size, color: new THREE.Color(config.color), map: textureCache[config.shape], transparent: true, opacity: config.opacity, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true });
            const sys = new THREE.Points(geo, mat); sys.userData = { config: config }; particleSystems[config.id] = sys; scene.add(sys);
        }

        function toggleMode() {
            if (isFireworkMode) return;
            // N·∫øu kh√¥ng c√≥ ·∫£nh, kh√¥ng cho v√†o gallery mode
            if (NOEL_DATA.images.length === 0) {
                console.log('‚ÑπÔ∏è Kh√¥ng c√≥ ·∫£nh, kh√¥ng th·ªÉ v√†o gallery mode');
                return;
            }
            const now = clock.getElapsedTime(); if (now - lastSwitchTime < SWITCH_COOLDOWN) return;
            lastSwitchTime = now; isGalleryMode = !isGalleryMode; const indicator = document.getElementById('mode-indicator');
            if (isGalleryMode) {
                indicator.innerText = "MODE: PHOTO GALLERY";
                indicator.style.color = "#FFD700";

                gsap.to(window, { duration: 1.2, jarOffsetY: -8, ease: "power2.inOut" });
                if (polaroidGroup) {
                    polaroidGroup.rotation.set(0, 0, 0);
                    polaroidGroup.children.forEach((polaroid, index) => {
                        polaroid.visible = true; polaroid.position.copy(polaroid.userData.startPos); polaroid.material.opacity = 0;
                        const t = polaroid.userData.targetPos; const r = polaroid.userData.targetRot;
                        gsap.to(polaroid.position, { x: t.x, y: t.y, z: t.z, duration: 1.2, ease: "power3.out", delay: index * 0.03 });
                        gsap.to(polaroid.rotation, { x: 0, y: r.y, z: r.z, duration: 1.2, ease: "power3.out", delay: index * 0.03 });
                        gsap.to(polaroid.material, { opacity: 1, duration: 0.8, delay: index * 0.03 });
                    });
                }
            } else {
                indicator.innerText = "MODE: JAR CONTROL";
                indicator.style.color = "rgba(255, 215, 0, 0.7)";

                gsap.to(window, { duration: 1.2, jarOffsetY: 0, ease: "back.out(0.8)", delay: 0.2 });
                if (polaroidGroup) {
                    polaroidGroup.children.forEach((polaroid, index) => {
                        const s = polaroid.userData.startPos;
                        gsap.to(polaroid.position, { x: s.x, y: s.y, z: s.z, duration: 1.0, ease: "power2.in", delay: index * 0.02 });
                        gsap.to(polaroid.material, { opacity: 0, duration: 0.8, delay: index * 0.02 });
                    });
                }
            }
        }

        function updateParticles(time) {
            if (isFireworkMode) return;
            Object.values(particleSystems).forEach(sys => {
                const cfg = sys.userData.config;
                if (cfg.id === 'inner_snow') { const alpha = 1.0 - Math.abs(jarOffsetY / 5.0); sys.material.opacity = Math.max(0, cfg.opacity * alpha); sys.position.y = jarOffsetY; }
                const positions = sys.geometry.attributes.position.array; const velocities = sys.geometry.attributes.velocity.array; const offsets = sys.geometry.attributes.offset.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    let ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2; positions[iy] -= velocities[i] * cfg.speed * 10;
                    if (cfg.drift) { positions[ix] += Math.cos(time * 0.5 + offsets[i]) * cfg.drift * 0.1; positions[iz] += Math.sin(time * 0.3 + offsets[i]) * cfg.drift * 0.1; }
                    if (positions[iy] < cfg.endY) { positions[iy] = cfg.startY; const r = cfg.radius * Math.sqrt(Math.random()); const t = Math.random() * 2 * Math.PI; positions[ix] = r * Math.cos(t); positions[iz] = r * Math.sin(t); }
                    if (cfg.id === 'inner_snow') { const d = Math.sqrt(positions[ix] * positions[ix] + positions[iz] * positions[iz]); if (d > cfg.radius) { const ratio = (cfg.radius - 0.02) / d; positions[ix] *= ratio; positions[iz] *= ratio; } }
                }
                sys.geometry.attributes.position.needsUpdate = true;
                if (carModel && cfg.rotateWithJar && inspectedPhoto === null && !isTouching) {
                    sys.rotation.y = carModel.rotation.y; sys.rotation.x = carModel.rotation.x;
                }
            });
        }

        function updatePolaroids(time) {
            if (isFireworkMode) return;
            if (!polaroidGroup) return;

            // Hand Gesture Rotation (Swipe effect)
            // N·∫øu l√† FIST th√¨ b·ªè qua logic xoay tay ƒë·ªÉ n√≥ r∆°i v√†o auto rotate
            if (STATE.hand.detected && inspectedPhoto === null && STATE.hand.gesture !== 'FIST') {
                const x = STATE.hand.x;
                let speed = 0;
                if (x < 0.4) speed = (x - 0.4) * 0.08;
                else if (x > 0.6) speed = (x - 0.6) * 0.08;
                polaroidGroup.rotation.y += speed;
            } else if (inspectedPhoto === null) {
                // Auto rotate constant slide show
                polaroidGroup.rotation.y += 0.002;
            }

            let closestDist = Infinity; let closestP = null;

            // First pass: Find closest
            polaroidGroup.children.forEach((p, i) => {
                if (p === inspectedPhoto) return;
                const worldPos = new THREE.Vector3();
                p.getWorldPosition(worldPos);
                const dist = worldPos.distanceTo(camera.position);
                if (dist < closestDist) { closestDist = dist; closestP = p; }
            });

            // Second pass: Update visuals (Blur/Focus effect)
            polaroidGroup.children.forEach((p, i) => {
                if (p === inspectedPhoto) return;

                const worldPos = new THREE.Vector3();
                p.getWorldPosition(worldPos);
                const dist = worldPos.distanceTo(camera.position);

                // Simple floating effect
                const off = p.userData.floatOffset;
                p.position.y = p.userData.targetPos.y + Math.sin(time * 0.5 + off) * 0.2;

                // FOCUS EFFECT
                // ·∫¢nh g·∫ßn nh·∫•t (kho·∫£ng c√°ch ~5-6) s·∫Ω r√µ, xa h∆°n s·∫Ω m·ªù d·∫ßn
                let opacity = 1.0;
                const minFocusDist = 7.0; // Kho·∫£ng c√°ch b·∫Øt ƒë·∫ßu m·ªù
                const maxBlurDist = 14.0; // Kho·∫£ng c√°ch m·ªù t·ªëi ƒëa

                if (dist > minFocusDist) {
                    // C√†ng xa c√†ng m·ªù, gi·∫£m xu·ªëng min 0.15
                    const t = Math.min(1, Math.max(0, (dist - minFocusDist) / (maxBlurDist - minFocusDist)));
                    opacity = 1.0 - (t * 0.85);
                }

                // N·∫øu l√† closestP th√¨ force opacity cao nh·∫•t c√≥ th·ªÉ (ƒë·ªÉ highlight)
                if (p === closestP) {
                    opacity = 1.0;
                    p.scale.lerp(new THREE.Vector3(1.15, 1.15, 1.15), 0.1);
                } else {
                    p.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                }

                // √Åp d·ª•ng opacity
                if (p.material) {
                    p.material.transparent = true;
                    p.material.opacity = opacity;
                }
            });
        }


        function getClosestPolaroid() {
            if (!polaroidGroup) return null; let closest = null; let minDistance = Infinity;
            polaroidGroup.children.forEach(p => {
                const worldPos = new THREE.Vector3(); p.getWorldPosition(worldPos); const distance = worldPos.distanceTo(camera.position);
                if (distance < minDistance && distance < 6.0) { minDistance = distance; closest = p; }
            }); return closest;
        }

        function addFrameToPhoto(photo) {
            // We can create a 2D DOM element or a 3D frame. DOM is easier for text.
            const frame = document.createElement('div');
            frame.id = 'photo-frame-overlay';
            frame.style.position = 'absolute';
            frame.style.top = '50%'; frame.style.left = '50%';
            frame.style.transform = 'translate(-50%, -50%) scale(0.8)';
            frame.style.width = '320px'; frame.style.height = '420px';
            frame.style.border = '10px solid #FFD700'; // Gold frame
            frame.style.boxShadow = '0 0 50px rgba(255, 215, 0, 0.5)';
            frame.style.backdropFilter = 'blur(5px)'; // Requested blurry frame
            frame.style.display = 'flex'; frame.style.flexDirection = 'column';
            frame.style.justifyContent = 'flex-end'; frame.style.alignItems = 'center';
            frame.style.pointerEvents = 'none'; frame.style.zIndex = '50';
            frame.style.opacity = '0'; frame.style.transition = 'opacity 0.5s';

            // Get Image URL from texture
            // This is tricky with canvas texture. But we have NOEL_DATA.images
            // We can just overlay transparently appropriately.
            // Actually, let's just use CSS for the frame border and text. The 3D plane is the image.

            const text = document.createElement('div');
            text.innerText = "Gi√°ng Sinh An L√†nh ‚ù§Ô∏è";
            text.style.color = "#FFD700"; text.style.fontFamily = "'Pinyon Script', cursive";
            text.style.fontSize = "36px"; text.style.marginBottom = "20px";
            text.style.textShadow = "0 2px 4px rgba(0,0,0,0.8)";
            frame.appendChild(text);

            document.body.appendChild(frame);
            setTimeout(() => frame.style.opacity = '1', 100);
        }

        function removeFrame() {
            const frame = document.getElementById('photo-frame-overlay');
            if (frame) {
                frame.style.opacity = '0';
                setTimeout(() => frame.remove(), 500);
            }
        }

        // H√†m l·∫•y ·∫£nh theo th·ª© t·ª± tu·∫ßn t·ª± (thay v√¨ random/closest)
        function getSequentialPolaroid() {
            if (!polaroidGroup || polaroidGroup.children.length === 0) return null;

            // L·∫•y ·∫£nh theo originalIndex thay v√¨ index m·∫£ng v√¨ th·ª© t·ª± m·∫£ng thay ƒë·ªïi khi attach/detach
            const photo = polaroidGroup.children.find(p => p.userData.originalIndex === currentPhotoIndex);
            return photo || null;
        }

        // H√†m hi·ªÉn th·ªã l·ªùi ch√∫c cho ·∫£nh
        function showPhotoMessage(photoIndex) {
            // X√≥a message c≈© n·∫øu c√≥
            if (currentMessageEl) {
                currentMessageEl.remove();
                currentMessageEl = null;
            }

            // L·∫•y l·ªùi ch√∫c t·ª´ PHOTO_MESSAGES
            const messageData = PHOTO_MESSAGES.find(m => m.id === photoIndex + 1);
            const messageText = messageData ? messageData.message : `Moment ${photoIndex + 1}`;

            // T·∫°o element hi·ªÉn th·ªã l·ªùi ch√∫c
            currentMessageEl = document.createElement('div');
            currentMessageEl.id = 'photo-message';
            currentMessageEl.style.cssText = `
                position: fixed;
                bottom: 15%;
                left: 50%;
                transform: translateX(-50%);
                font-family: 'Pinyon Script', cursive;
                font-size: 28px;
                color: #FFD700;
                text-shadow: 0 2px 8px rgba(0,0,0,0.8), 0 0 20px rgba(255,215,0,0.3);
                text-align: center;
                z-index: 60;
                padding: 10px 30px;
                background: rgba(0,0,0,0.5);
                border-radius: 10px;
                border: 1px solid rgba(255,215,0,0.3);
                opacity: 0;
                transition: opacity 0.5s ease;
                max-width: 80%;
            `;
            currentMessageEl.innerText = messageText;
            document.body.appendChild(currentMessageEl);

            // Fade in
            setTimeout(() => currentMessageEl.style.opacity = '1', 100);
        }

        // H√†m ·∫©n l·ªùi ch√∫c
        function hidePhotoMessage() {
            if (currentMessageEl) {
                currentMessageEl.style.opacity = '0';
                setTimeout(() => {
                    if (currentMessageEl) {
                        currentMessageEl.remove();
                        currentMessageEl = null;
                    }
                }, 500);
            }
        }

        function animatePhotoPopup(show) {
            const now = clock.getElapsedTime();
            const lyrics = document.getElementById('lyrics-container');

            if (show) {
                if (inspectedPhoto || now - lastDropTime < 0.8) return;

                // Ki·ªÉm tra ƒë√£ xem h·∫øt ·∫£nh ch∆∞a
                if (currentPhotoIndex >= TOTAL_PHOTOS) {
                    console.log('ƒê√£ xem h·∫øt t·∫•t c·∫£ ·∫£nh!');
                    return;
                }

                // L·∫•y ·∫£nh theo th·ª© t·ª± tu·∫ßn t·ª± (thay v√¨ closest)
                inspectedPhoto = getSequentialPolaroid();
                if (!inspectedPhoto) return;

                // Hide lyrics to prevent overlap
                if (lyrics) lyrics.style.opacity = 0;

                // Auto-close after 5 seconds
                if (autoCloseTimer) clearTimeout(autoCloseTimer);
                autoCloseTimer = setTimeout(() => {
                    if (isZoomedIn) {
                        isZoomedIn = false;
                        animatePhotoPopup(false);
                    }
                }, 5000);

                scene.attach(inspectedPhoto); inspectedPhoto.visible = true; inspectedPhoto.material.opacity = 1;

                // Move to center screen
                gsap.to(inspectedPhoto.position, { x: 0, y: 0, z: camera.position.z - 4.0, duration: 0.8, ease: "back.out(1.2)" });
                gsap.to(inspectedPhoto.rotation, { x: 0, y: 0, z: 0, duration: 0.8 });
                gsap.to(inspectedPhoto.scale, { x: 1.2, y: 1.2, z: 1.2, duration: 0.8 });

            } else {
                if (autoCloseTimer) clearTimeout(autoCloseTimer);
                if (!inspectedPhoto) return;

                removeFrame();

                // Show lyrics again
                if (lyrics) lyrics.style.opacity = 1;

                const p = inspectedPhoto;

                // ƒê√°nh d·∫•u ·∫£nh ƒë√£ xem v√† tƒÉng index
                viewedPhotos.add(currentPhotoIndex);
                currentPhotoIndex++;

                // C·∫≠p nh·∫≠t UI hi·ªÉn th·ªã progress
                const indicator = document.getElementById('mode-indicator');
                if (indicator) {
                    indicator.innerText = `GALLERY (${currentPhotoIndex}/${TOTAL_PHOTOS})`;
                }

                inspectedPhoto = null;
                lastDropTime = now;

                polaroidGroup.attach(p);
                const t = p.userData.targetPos;
                const r = p.userData.targetRot;

                gsap.to(p.position, { x: t.x, y: t.y, z: t.z, duration: 0.8, ease: "back.out(1.0)" });
                gsap.to(p.scale, { x: 1, y: 1, z: 1, duration: 0.7 });
                if (isGalleryMode) gsap.to(p.rotation, { x: 0, y: r.y, z: r.z, duration: 0.7, ease: "power2.out" }); else gsap.to(p.material, { opacity: 0, duration: 0.5 });
            }
        }

        function initHandTracking() {
            const video = document.getElementById('input_video'); const canvas = document.getElementById('webcam-canvas'); const ctx = canvas.getContext('2d'); const stats = document.getElementById('cam-stats');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(results => {
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                ctx.save(); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
                STATE.hand.gesture = 'NONE';
                if (results.multiHandLandmarks.length > 0) {
                    STATE.hand.detected = true; const lm = results.multiHandLandmarks[0]; STATE.hand.x = 1 - lm[0].x; STATE.hand.y = lm[0].y;
                    const tips = [8, 12, 16, 20]; const pips = [6, 10, 14, 18]; let extended = [];
                    for (let i = 0; i < 4; i++) extended.push(Math.hypot(lm[tips[i]].x - lm[0].x, lm[tips[i]].y - lm[0].y) > Math.hypot(lm[pips[i]].x - lm[0].x, lm[pips[i]].y - lm[0].y));
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    const isFist = extended.every(e => e === false);

                    if (extended[0] && extended[1] && !extended[2] && !extended[3]) STATE.hand.gesture = 'VICTORY';
                    else if (isFist) STATE.hand.gesture = 'FIST';
                    else if (pinchDist < 0.05) STATE.hand.gesture = 'PINCH';
                    else STATE.hand.gesture = 'OPEN';
                } else { if (STATE.hand.detected) { STATE.hand.detected = false; STATE.hand.gesture = 'NONE'; } }
                ctx.restore();
            });

            let frameCounter = 0;
            const cameraUtils = new Camera(video, {
                onFrame: async () => {
                    if (frameCounter % AI_SKIP_FRAMES === 0) {
                        await hands.send({ image: video });
                    }
                    frameCounter++;
                },
                width: 320,
                height: 240
            });
            cameraUtils.start();
        }

        // Th√™m bi·∫øn global ch·∫∑n spam action
        let lastActionTime = 0;
        const ACTION_DEBOUNCE = 2.0;

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            if (mixer) mixer.update(dt);
            updateLyrics(); updateParticles(time); updatePolaroids(time); updateBackgroundParticles(time, dt);

            const currentGesture = STATE.hand.gesture;

            if (currentGesture === 'VICTORY' && lastGesture !== 'VICTORY') {
                // toggleMode(); 
            }

            // OPEN gesture: Xem ·∫£nh (zoom in)
            if (currentGesture === 'OPEN' && isGalleryMode && !isTouching) {
                if (!isZoomedIn && currentPhotoIndex < TOTAL_PHOTOS) {
                    if (time - lastActionTime > ACTION_DEBOUNCE) {
                        isZoomedIn = true;
                        lastActionTime = time;
                        animatePhotoPopup(true);
                    }
                }
            }

            // FIST gesture: ƒê√≥ng ·∫£nh (zoom out) HO·∫∂C k·∫øt th√∫c
            if (currentGesture === 'FIST') {
                if (isGalleryMode && isZoomedIn) {
                    if (time - lastActionTime > ACTION_DEBOUNCE) {
                        isZoomedIn = false;
                        lastActionTime = time;
                        animatePhotoPopup(false);
                    }
                } else if (!isFireworkMode && currentPhotoIndex >= TOTAL_PHOTOS) {
                    if (lastGesture !== 'FIST') triggerFireworkMode();
                }
            }

            lastGesture = currentGesture;

            if (isTouching) {

            } else if (STATE.hand.detected) {
                const targetY = (STATE.hand.x - 0.5) * (Math.PI * 6.0);
                const targetX = (STATE.hand.y - 0.5) * (Math.PI * 1.0);

                STATE.currentRotation.x += (targetX - STATE.currentRotation.x) * 0.1;
                STATE.currentRotation.y += (targetY - STATE.currentRotation.y) * 0.1;

                if (inspectedPhoto === null) {
                    if (!isGalleryMode) {
                        if (carModel) { carModel.rotation.y = STATE.currentRotation.y; carModel.rotation.x = STATE.currentRotation.x; }
                    }
                    else if (carModel) {
                        carModel.rotation.y = STATE.currentRotation.y * 0.5;
                        carModel.rotation.x = STATE.currentRotation.x * 0.5;
                    }
                }
            } else if (carModel && !isGalleryMode && inspectedPhoto === null) {
                carModel.rotation.y += 0.4 * dt;
                carModel.rotation.x *= 0.95;
                STATE.currentRotation.y = carModel.rotation.y;
                STATE.currentRotation.x = carModel.rotation.x;
            }

            if (!isGalleryMode) {
                let ts, tp, tz;
                if (isZoomedIn) { ts = SCENE_CONFIG.scaleNear; tp = SCENE_CONFIG.posNear; tz = SCENE_CONFIG.camZNear; }
                else { ts = SCENE_CONFIG.scaleFar; tp = SCENE_CONFIG.posFar; tz = SCENE_CONFIG.camZFar; }
                camera.position.z += (tz - camera.position.z) * SCENE_CONFIG.zoomSpeed;
                if (carModel) { carModel.scale.setScalar(carModel.scale.x + (ts - carModel.scale.x) * SCENE_CONFIG.zoomSpeed); carModel.position.x += (tp.x - carModel.position.x) * SCENE_CONFIG.zoomSpeed; carModel.position.y += (tp.y - carModel.position.y) * SCENE_CONFIG.zoomSpeed; }
            }
            if (carModel) { carModel.position.y += jarOffsetY; if (jarOffsetY < -2) carModel.scale.setScalar((isZoomedIn ? SCENE_CONFIG.scaleNear : SCENE_CONFIG.scaleFar) * Math.max(0, 1 - (Math.abs(jarOffsetY) / 10))); }

            if (composer && ENABLE_POST_PROCESSING) composer.render();
            else renderer.render(scene, camera);
        }
        init();
    </script>
</body>

</html>